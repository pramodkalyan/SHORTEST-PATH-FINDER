
package Client;
import java.util.Comparator;
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Random;
import java.lang.Math;
import java.util.PriorityQueue;
import java.util.Scanner;


public class HeapPathFinder //implements Comparator<Node>
{
    int N;
    List <Integer>[] adj;
    List <Integer>[] edgeLengths;
    List <Integer>[] possibleScores;
    List <Integer>[] shortestPath;
    List discoveredNodes;
    int[] potentialAdditions;
    int[] potentialAdditionsScore;
    int[] potentialAdditionsPreviousNode;
    int[] newNeighboursPotentialScore;
    boolean[] insideX;
    boolean[][] addedToScore;
    int[] score;
    int source;
    int[] X;
    int maxNode = 0;
    int nodesAdded = 0;
    
    Node[] vertex;
    
    
    PriorityQueue<Node> pq;
    
    
    public HeapPathFinder(int tempN)
    {
        this.N = tempN;
        adj = (List<Integer>[]) new List[N];
        for (int i = 0; i < N; i++)
            adj[i] = new ArrayList<Integer>();
        
        shortestPath = (List<Integer>[]) new List[N];
        for (int i = 0; i < N; i++)
            shortestPath[i] = new ArrayList<Integer>();
        
        X = new int[N];
        score = new int[1000];
        
        edgeLengths = (List<Integer>[]) new List[N];
        for (int i = 0; i < N; i++)
            edgeLengths[i] = new ArrayList<Integer>();
        
        insideX = new boolean[N];
        discoveredNodes = new ArrayList<Integer>();
        
        vertex = new Node[N];
        for (int i = 0; i < N; i++)
            vertex[i] = new Node(i);
        
        Comparator<Node> comparator = new NodeComparator();
        pq = new PriorityQueue<Node>(N, comparator);
    }
    
    
    // Reads the graph generated by GraphGenerator and adds it to adjacency lists that hold neighbours and weights
    public void readMatrix (int[][] matrix)
    {
        for (int i = 0; i < matrix.length; i++)
        {
            for (int j = 0; j < matrix.length; j++)
            {
                if (matrix[i][j] != 0 && i <= j)
                {
                    adj[i].add(j);
                    adj[j].add(i);
                    edgeLengths[i].add(matrix[i][j]);
                    edgeLengths[j].add(matrix[i][j]);
                }
            }
        }
    }
    
    // Creates a heap consisting of all the nodes in the graph
    public void createHeap()
    {
        for (int i = 0; i < N; i++)
        {
            pq.add(vertex[i]);
        }
    }
    
    // Finds all the shortest paths from the source vertex to each other vertex in the graph
    public void findPaths(int s)
    {
        source = s;
        pq.remove(vertex[s]);	// Removes s from the heap as it has been visited
        vertex[s].setScore(0);               
        shortestPath[s].add(s);	// Adds the shortest path from the source to itself. In this case, it consists only of the node itself
        
        X[nodesAdded++] = s;	//Adds s to "X". X represents all nodes that are visited.
        insideX[s] = true;

        while (nodesAdded < N)	// Keeps traversing until all the nodes have been visited
        {
            addNode();
        }
                
    }
    
    // Traverses the graph by Dijkstra's algorithm, adding nodes to "X" appropriately
    public void addNode()
    {
        int k = 0;
        for (int i = 0; i < nodesAdded; i++) // Traverses All nodes
        {
            int node = X[i];  
            for (int j = 0; j < adj[node].size(); j++)  // Traversing through all neighbours of node
            {
                
                int neighbour = adj[node].get(j);
                int weight = edgeLengths[node].get(j);
                
                  						// If the neighbour has not been added to X, removes the neighbour from the heap
                						// checks if the score of the path through 'node' to that neighbour is lesser than its already
                						// existing score, and if so, changes its score and path from the source appropriately	
                if (!insideX[neighbour])
                {
                    pq.remove(vertex[neighbour]);                    
                    int previousNeighbour = node;                    
                    vertex[neighbour].updateScore(vertex[node].score + weight, previousNeighbour);
                    pq.add(vertex[neighbour]);                    
                }
            }
        }
        
        
        Node newNode = pq.poll();	// newNode is the node extracted from the heap (consisting of all nodes not yet visited) which has the least score.
        							// poll is equivalent to extractMin
        int newNodeIndex = newNode.index;	// newNodeIndex contains the actual value of the node, as is to be used in the graph.
        insideX[newNodeIndex] = true;
        X[nodesAdded++] = newNodeIndex;
        
        int previousNode = vertex[newNodeIndex].previousNeighbour;
        for (int i = 0; i < shortestPath[previousNode].size(); i++)        
            shortestPath[newNodeIndex].add(shortestPath[previousNode].get(i));
        
        shortestPath[newNodeIndex].add(newNodeIndex);        
    }
    
    // Transfers the shortest paths to GraphGenerator
    public void setPath(Client client)
    {        
        client.shortestPathCl = shortestPath;        
    }    
        
    public static void main(String[] args) 
    {
        Scanner in =new Scanner(System.in);
        int n;
        do
        {
            System.out.println("Enter number of nodes (between 2 and 80)");
            n = in.nextInt();
            if (n < 2 || n > 80)
                System.out.println("Not valid");
        }while(!(n<81 && n >1));
        Client client = new Client(n);
        //Client c2=new Client(client);
        client.createE();
        client.createAdjMatrix();        
    }
}

class Node
{
    int index;
    int score;
    int previousNeighbour;
    
    Node(int i)
    {
        index = i;
        score = 100000000;
    }
    
    void setScore(int s)
    {
        score = s;
    }
    
    void updateScore(int newScore, int newPreviousNeighbour)
    {
        score = min(score, newScore);
        if (score == newScore)
            previousNeighbour = newPreviousNeighbour;
    }
    
    int min(int x, int y)
    {
        if (x<y)
            return x;
        else
            return y;
    }
}

class NodeComparator implements Comparator<Node>
{
    @Override
    public int compare(Node n1, Node n2)
    {
        if (n1.score > n2.score)
            return 1;
        else if (n1.score < n2.score)
            return -1;
        else 
            return 0;                      
    }    
}
